rk 32 130 pts，挂分比得分高.jpg

# T1

这不宝宝题吗

赛后一看 RE0 吓死我了原来是将军用数据打下了 ZROJ :writing_hand::writing_hand::writing_hand: \\:sob:/  \\:sob:/  \\:sob:/

# T2

~~这不宝宝题吗~~这**不是**宝宝题

最后还差[数据删除]秒没写完 O(1) LCA，只有之前交的一个倍增 LCA。

结果因为数组开小<ruby>DSC<rt>Dangerous System Call</rt></ruby> 挂成 30 pts 了？？？我不理解。我已经开大了很多了啊。

不过这个做法（$O(m^2\log m)$）本来就是 30 分。也不算挂分吧 :/

---

考虑特殊性质 A 链上的情况，不难发现此时每个点连向的是一段区间，不妨线段树优化建边，可以再多拿 15 pts。

如何推广到树上？可以边分治 / 点分治+哈夫曼合并。可以做到两个 log。

另解：考虑 Kosaraju[^1] 算法：两次 DFS，第一次给所有顶点做后序遍历编号；第二次在反向图上以标号从大到小做 DFS，每次访问没访问过的点，那一次访问的点就是一个 SCC。

如何得到后序遍历？我们是如何进行遍历的？把它放到原树上，相当于找到方圆 $mid-1$ 中的一个*嘟々*并跳到它的匹配点。

考虑建出点分树，不难实现这一过程，反向图上的 DFS 同理。

[^1]: S.Rao.Kosaraju。虽然听起来是个日本名字~~而且 Rao 可以写作莉绪~~，但其实是个印度人

# T3

只会 $O(nm)$。怎么 MLE 挂成零分了？？？不就是开了两个 5e7 大小的数组嘛（逃

早知道把其中一个换成 bitset 了。

---

注意到，线段树合并新建结点数是原来两棵线段树共同拥有的结点数。因此，我们不关心每个点上树的结构，只关心点存在与否。

考虑观察一个线段树结点 $f$ 对第一问答案的贡献：

- 若 $u$ 存在有出点 $v$ 能到达 $f$ 中的点，记为 $k$ 个，则贡献 $k-1$
- 如果 $u$ 是 $f$ 中的点，则贡献 $1$
- 如果前两条同时成立，再贡献 $1$

对第一条转化为：

- 若 $u$ 有 $k$ 个出点 $v$ 能到达 $f$ 中的点，则贡献 $k$
- 若 $u$ 存在有出点 $v$ 能到达 $f$ 中的点，贡献 $-1$

其中第 (1) 条即为：

- 若 $v$ 能到达 $f$ 中的点，则贡献 $x$，其中 $x$ 为其入边数

第 (2) 条与第三条加起来就是：

- 若 $u$ 有出点 $v$ 能到达 $f$ 中的点，且 $u$ 本身不是 $f$ 中的点，则贡献 $-1$

这个可以拆成：

- 如果 $u$ 能到达 $f$ 中的点，贡献 $-1$
- 如果 $u$ 是 $f$ 中的点，贡献 $1$

最终得到：

- 如果 $u$ 能到达 $f$ 中的点，贡献 $x-1$，其中 $x$ 为其入边数
- 如果 $u$ 是 $f$ 中的点，贡献 $2$

把多个 $f$ 拼起来，在每个 $u$ 统计贡献：

- 记 $u$ 可达的线段树结点数为 $s$，则贡献 $(x-1)s$
- 记 $u$ 在线段树的祖先（包括自己）数为 $d$，则贡献 $2d$

第一问直接 bitset 做就好了，对于第二问，第二类贡献的消除是 trivial 的。

对于第一类贡献，譬如我们现在在算 $v$ 的答案，那么一个 $u$ 可以对 $v$ 产生 $-(x-1)$ 的贡献，当且仅当 $u$ 可达 $v$，且在 $f$ 中 $u$ 的可达点有且仅有 $v$。

可以通过维护 DAG 中每个点的可达点中的前驱后继（直接遍历可达 bitset 即可）来得到其在线段树上的*支配点*集合，使用 $O(n\log n)\sim O(1)$ LCA 可以做到 $O(n^2)$。

但是空间还是过不去，可以用分块 bitset 的方式降低空间消耗。

类似分块每块单独处理的技巧，对于跨块的前驱后继对特殊处理即可。

每块取 $w=64$ 就不用写 bitset 了。
