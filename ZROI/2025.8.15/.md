# T1

注意到，如果先做一遍前缀 ckmax 再做一遍后缀 ckmax，相当于区间覆盖为 max。因此，一个区间最多有一个标记。

以当前单调连续段个数为势能，可以直接用 ODT 维护。

再用一个线段树辅助维护二分/区间覆盖+求和 即可。

# T2

根据经典结论，答案就是把区间划分为 $k$ 段，第 $i$ 段的 $i$ 的个数的最小值的最大值。

然后直接拿线段树维护就可以了？？？合并 $O(k^3)$

# T3

先考虑「能够全部清空」的串满足的条件：

- 长度为偶数
- 不难发现，「消无可消」的境地一定要么为空，要么为 $AB$。
- 如果 $B$ 放在前面或者 $A$ 放在后面，那么我们可以先消掉它。因此，如果不能清空，它的形式一定为 $A....B$。
- 但是光这样不行，比如我们发现 $AABB$ 就是可以消掉的。可以猜测，我们一定得满足两端的 $A$ 和 $B$ 不能都被同时消掉。如果被消掉，需要有一个补充代替它原来的位置。
- 最终，我们发现需要满足 $A[AA|BA|BB]^*B$ 的<ruby>形式<rt>pattern</rt></ruby>，那么，能够全部清空就当且仅当不满足这个形式。

然后不难发现，串 $s$ 能够转化为串 $t$，当且仅当 $t$ 是 $s$ 的子序列，且 $s$ 删掉 $t$ 的部分后形成的若干连续段都是能够清空的。

由此不难贪心地做匹配。

比如我们现在想要找到 $t_i$ 的匹配 $s_y$，上一个 $t_{i-1}$ 在 $s$ 中的匹配为 $s_x$（初始时，$x=0$）。首先需要满足的是 $y>x$ 且 $y-x\equiv 1\pmod 2$。分类讨论：

- 如果 $s_x=A$
  - 如果 $t_i=A$，那么直接找到最近的 $y$ 使 $s_y=A$ 即可。即使 $(x,y)$ 不能被消尽，那么最终余下的为 $AABA$，那么对后两个消一次即可得到 $AA$。
  - 如果 $t_i=B$，我们仍然希望找到最近的 $y$ 使 $s_y=B$，但是有可能不合法。注意到如果不合法一定形如 $AA[AA|BA|BB]^*BB$，也就是说选 $BB$ 是不好的，但是 $AA$ 和 $BA$ 不能选。因此找到这个奇偶位上第一个 $AB$ 即可。
- 如果 $s_x=B$
  - 如果 $t_i=A$，同理，只要找到最近的 $y$ 使 $s_y=A$ 即可。
  - 如果 $t_i=B$，同理，只要找到最近的 $y$ 使 $s_y=B$ 即可。

方便起见，可以认为 $s_0=A$。

最后还需要判断 $(x,n]$ 能否被删除。首先如果 $s_x=B$ 则一定可以消除，因为如果最后只剩 $BAB$ 可以把前两个消掉。因此只需要判一下 A 结尾的情况即可。

上面的贪心已经是一个子序列自动机的形状了，所以直接路径计数即可。