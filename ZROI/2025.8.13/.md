# T1

第一次接触到光速幂。

其实类似 BSGS，总之可以比快速幂少一个 log。

如果是两层光速幂，就是处理 $A^1,A^2,\dots,A^{\sqrt V}$ 和 $A^{\sqrt V},A^{2\sqrt V},\dots,A^V$。

三层的话，就是维护 $A^1,A^2,\dots,A^{\sqrt[3]V}$ 和 $A^{\sqrt[3]V},A^{2\sqrt[3]V},\dots,A^{V^{2/3}}$ 和 $A^{V^{2/3}},A^{2V^{2/3}},\dots,A^{V}$。

每次得到一个值需要三次矩乘，但是预处理复杂度降低了。

每次能做向量乘矩阵就做向量乘矩阵，可以做到 $O(nk^2+V^{1/3}k^3)$。

# T2

神秘技巧。注意到允许的误差范围极大，所以可以直接把答案二进制分组。

所以值域只有 log 大小。枚举一个 $i$，把 $\le i$ 的数当作 $1$，$>i$ 的数当作 $-1$，统计路径权值和 $\ge 0$ 的路径数，即得到中位数 $\le i$ 的路径。直接长剖做就可以了。

# T3

太神秘了。赛时只会随机化，成功拿到 0 pts 的好成绩。

![盗來の図](https://cdn.luogu.com.cn/upload/image_hosting/9u7uh9at.png)

如图，考虑把每个点分配给 $r_i^2-d_i^2$ 最大的圆，其中 $d_i=|p-C_i|$ 即到圆心的距离。

那么，每两个圆之间形成一条直线分割整个平面。进一步，一个圆的管辖范围是其到其他所有圆的半平面之交。可以直接做半平面交。

注意到这个形成平面分割，可以想象最后总的线段数量是 $O(n)$ 的，可以用欧拉公式证明。因为面的数量是 $n$，而且每个点的度数至少为 $3$（不然就退化为线段了）。

<ruby>基本功<rt>神秘学</rt></ruby>做法：

<p style="color: yellow;">宜为圣经，永世长颂</p>。

```c++
#include <algorithm>
#include <cassert>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <set>
#include <vector>

#define fi first
#define se second
#define pb push_back
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)
#define for_each(i, s) for (int i = 0; i < (int)s.size(); i++)

#define assert(x)

/**
 * Computing Geometry Library
 * ref1: https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all
 * ref2: https://darkbzoj.tk/problem/2178
 * @author Sshwy
 */
namespace cg {
typedef long double Vt;
const Vt eps = 1e-9;
const Vt PI = 3.1415926535897932626;

using std::make_pair;
using std::max;
using std::min;
using std::pair;
using std::swap;
using std::vector;

bool is_zero(Vt x) { return -eps < x && x < eps; }
bool eq(Vt x, Vt y) { return is_zero(x - y); }
bool lt(Vt x, Vt y) { return !eq(x, y) && x < y; }
bool gt(Vt x, Vt y) { return !eq(x, y) && x > y; }

struct Vec {
  Vt x, y;
  Vec() { x = y = 0; }
  Vec(Vt _x, Vt _y) { x = _x, y = _y; }

  Vt length() const { return sqrt(x * x + y * y); }
  // 方向角，单位 rad, [-pi, pi]
  Vt ang() const { return atan2(y, x); }
  // 方向不变，调整长度为 len （可以是负数）
  Vec resize(Vt len) const {
    if (*this) {
      Vt rate = len / length();
      return Vec(x * rate, y * rate);
    } else
      return Vec(0, 0);
  }

  Vec operator+(const Vec V) const { return Vec(x + V.x, y + V.y); }
  Vec operator-() const { return Vec(-x, -y); }
  Vec operator-(const Vec V) const { return *this + (-V); }
  Vec operator*(const Vt a) const { return Vec(x * a, y * a); }
  friend Vec operator*(const Vt a, const Vec v) { return v * a; }
  Vec operator/(const Vt a) const { return Vec(x / a, y / a); }
  operator bool() const { return !(is_zero(x) && is_zero(y)); }
  bool operator==(const Vec V) const { return bool(*this - V) == 0; }
  bool operator!=(const Vec V) const { return bool(*this - V) != 0; }
  bool operator<(const Vec V) const {
    return eq(x, V.x) ? lt(y, V.y) : lt(x, V.x);
  }
  bool operator>(const Vec V) const {
    return eq(x, V.x) ? gt(y, V.y) : gt(x, V.x);
  }
};
typedef Vec Pt;

// 顺时针旋转 90 度
Vec r90_clockwise(const Vec v) { return Vec(v.y, -v.x); }

struct Ln {
  Pt st, ed;
  Ln(Pt _p1, Pt _p2) { st = _p1, ed = _p2; }
  Ln operator+(Pt p) { return Ln(st + p, ed + p); } // shift
  Ln operator-(Pt p) { return Ln(st - p, ed - p); }
  Vec vec() const { return ed - st; }
  Vec dir() const { return vec().resize(1); }
};
typedef Ln Seg;

// 点积 a dot b == |a||b|cos theta
Vt dot(const Vec a, const Vec b) { return a.x * b.x + a.y * b.y; }
// 叉积 两个向量围成的有向面积
Vt det(const Vec a, const Vec b) { return a.x * b.y - a.y * b.x; }
/// 向量夹角
/// @return 一个 (-PI, PI) 内的数表示角度，单位 rad
Vt angle(Vec a, Vec b) {
  bool sign = det(a, b) < 0;
  if (sign)
    swap(a, b);
  Vt res = b.ang() - a.ang();
  if (res < 0)
    res += 2 * PI;
  return sign ? -res : res;
}

// 投影 @param L 直线  @param p 要求投影的点 @return p 在 L
// 上的投影坐标（即垂足）
Pt proj(Ln L, Pt p) {
  Vec d = L.ed - L.st;
  return L.st + d.resize(dot(d, p - L.st) / d.length());
}
// 对称点 @param L 直线 @param p 点 @return p 关于直线 L 的对称点
Pt refl(Ln L, Pt p) { return Vt(2) * (proj(L, p) - p) + p; }
// 判断向量是否平行 (必须归一化不然 det 结果会带面积影响精度)
bool parallel(Vec a, Vec b) { return is_zero(det(a.resize(1), b.resize(1))); }
// 判断直线是否平行
bool parallel(Ln a, Ln b) { return parallel(a.ed - a.st, b.ed - b.st); }
// 判断向量是否垂直
bool orthogonal(Vec a, Vec b) { return is_zero(dot(a, b)); }
// 判断直线是否垂直
bool orthogonal(Ln a, Ln b) { return orthogonal(a.ed - a.st, b.ed - b.st); }
// 判断点 p 是否在直线L上
bool on_ln(Ln L, Pt p) { return parallel(L.ed - L.st, p - L.st); }
// 判断两直线是否重合
bool coincident(Ln a, Ln b) { return on_ln(a, b.st) && on_ln(a, b.ed); }
// 判断点 p 是否与有向线段共线且在反向延长线上
bool on_ln_back(Seg sl, Pt p) {
  Vec a = sl.ed - sl.st, b = p - sl.st;
  return parallel(a, b) && lt(dot(a, b), 0);
}
// 判断点 p 是否与有向线段共线且在反向延长线上（含起点）
bool on_ln_back_include(Seg sl, Pt p) {
  Vec a = sl.ed - sl.st, b = p - sl.st;
  return parallel(a, b) && !gt(dot(a, b), 0);
}
// 判断点 p 是否与有向线段共线且在正向延长线上
bool on_ln_front(Seg sl, Pt p) {
  Vec a = sl.st - sl.ed, b = p - sl.ed; // 倒过来
  return parallel(a, b) && lt(dot(a, b), 0);
}
// 判断点 p 是否与有向线段共线且在正向延长线上（含终点）
bool on_ln_front_include(Seg sl, Pt p) {
  Vec a = sl.st - sl.ed, b = p - sl.ed; // 倒过来
  return parallel(a, b) && !gt(dot(a, b), 0);
}
// 判断点 p 是否在线段上（含端点）
bool on_seg(Seg sl, Pt p) {
  return on_ln(sl, p) && !on_ln_back(sl, p) && !on_ln_front(sl, p);
}
// 两条直线的交点。需确保两条直线不平行
Pt inter(Ln a, Ln b) {
  assert(!parallel(a, b));
  Vt x = det(a.st - b.st, b.ed - b.st), y = det(b.ed - b.st, a.ed - b.st);
  return a.st + (a.ed - a.st) * x / (x + y);
}
// 判断两个线段是否相交（含边界）
bool is_seg_inter(Seg a, Seg b) {
  if (coincident(a, b)) {
    if (on_seg(a, b.st) || on_seg(a, b.ed) || on_seg(b, a.st) ||
        on_seg(b, a.ed))
      return true;
    else
      return false;
  } else if (parallel(a, b)) {
    return false;
  } else {
    Pt o = inter(a, b);
    if (on_seg(a, o) && on_seg(b, o))
      return true;
    else
      return false;
  }
}
// 两个点的距离
Vt dst(Pt a, Pt b) { return (b - a).length(); }
// 点到直线的距离
Vt dst(Ln L, Pt p) { return (p - proj(L, p)).length(); }
// 两个线段的距离
Vt dst(Seg a, Seg b) {
  if (is_seg_inter(a, b))
    return 0;
  Vt res = dst(a.st, b.st);
  res = min(res, dst(a.st, b.ed));
  res = min(res, dst(a.ed, b.st));
  res = min(res, dst(a.ed, b.ed));
  Pt o;
  if (o = proj(b, a.st), on_seg(b, o))
    res = min(res, dst(a.st, o));
  if (o = proj(b, a.ed), on_seg(b, o))
    res = min(res, dst(a.ed, o));
  if (o = proj(a, b.st), on_seg(a, o))
    res = min(res, dst(b.st, o));
  if (o = proj(a, b.ed), on_seg(a, o))
    res = min(res, dst(b.ed, o));
  return res;
}
// 求简单多边形面积 @param g 多边形顶点集
Vt area(const vector<Pt> &g) {
  Vt res = 0;
  for (unsigned i = 0; i < g.size(); i++)
    res += det(g[i], g[(i + 1) % g.size()]);
  res /= 2;
  return abs(res);
}
// 判断是否是凸包 @param g 多边形顶点集
bool is_convex(const vector<Pt> &g) {
  if (g.size() < 3)
    return true;
  int flag = 0;
  for (unsigned i = 0; i < g.size(); i++) {
    int j = (i + 1) % g.size(), k = (i + 2) % g.size();
    Vt sig = det(g[j] - g[i], g[k] - g[j]);
    if (lt(sig, 0)) {
      if (flag == 1)
        return false;
      else
        flag = -1;
    }
    if (gt(sig, 0)) {
      if (flag == -1)
        return false;
      else
        flag = 1;
    }
  }
  return true;
}
// 三个点两两之间的差向量是逆时针转动
bool is_ctrclk(Pt a, Pt b, Pt c) { return gt(det(b - a, c - b), 0); }
// 求凸包 @param g 多边形顶点集
vector<Pt> convex(vector<Pt> g) {
  sort(g.begin(), g.end());
  if (g.size() < 3)
    return g;

  vector<bool> vis(g.size(), false);
  vector<int> s(g.size() + 1, 0);
  int ls = 0;

  for (unsigned i = 0; i < g.size(); i++) {
    while (ls > 1 && !is_ctrclk(g[s[ls - 2]], g[s[ls - 1]], g[i]))
      --ls;
    s[ls] = i, ++ls;
  }
  FOR(i, 0, ls - 1) vis[s[i]] = true;
  vis[0] = false;
  for (int i = g.size() - 1; i >= 0; i--)
    if (!vis[i]) {
      while (ls > 1 && !is_ctrclk(g[s[ls - 2]], g[s[ls - 1]], g[i]))
        --ls;
      s[ls] = i, ++ls;
    }
  assert(s[0] == s[ls - 1]);

  vector<Pt> cvx;
  FOR(i, 0, ls - 2) cvx.pb(g[s[i]]);
  return cvx;
}
// 求点集的最远点对距离（正确性还不太懂，也许有锅）@param v 点集
Vt diameter(const vector<Pt> &v) {
  vector<Pt> g = convex(v);
  Vt dist = 0;
  unsigned pos = 0;
  for (unsigned i = 0; i < g.size(); i++) {
    while (pos + 1 < g.size() && dst(g[i], g[pos]) < dst(g[i], g[pos + 1]))
      ++pos;
    dist = max(dist, dst(g[i], g[pos]));
  }
  return dist;
}
/// 判断点p与多边形的包含关系
/// @param g 多边形顶点集
/// @return 0 表示在多边形外，1 表示在边上，2表示在多边形内
int polygon_pt_containment(vector<Pt> g, Pt p) {
  Ln L(Vec(p.x - 1, p.y), p); // 水平方向的射线
  int cnt = 0;
  for (unsigned i = 0; i < g.size(); i++) {
    int j = (i + 1) % g.size();
    Ln e(g[i], g[j]);
    if (on_seg(e, p))
      return 1;
    if (parallel(L, e)) {
      // do nothing.
    } else if (on_ln_front(L, g[i])) {
      if (g[i].y > g[j].y)
        ++cnt;
    } else if (on_ln_front(L, g[j])) {
      if (g[j].y > g[i].y)
        ++cnt;
    } else {
      Pt o = inter(L, e);
      if (on_seg(e, o) && on_ln_front(L, o))
        ++cnt;
    }
  }
  if (cnt % 2)
    return 2;
  return 0;
}

struct Cir {
  Pt o;
  Vt r;
  Cir() { r = 0; }
  Cir(Pt _o, Vt _r) { o = _o, r = _r; }
};
/// 判断两个圆的位置关系（切线数量）
/// @param a 第一个圆
/// @param b 第二个圆
/// @return 0 表示包含，1 表示内切，2 表示相交，3 表示外切，4 表示相离
int cir_inter_kind(Cir a, Cir b) {
  Vt d = dst(a.o, b.o);
  if (gt(d, a.r + b.r))
    return 4;
  if (eq(d, a.r + b.r))
    return 3;
  if (gt(d, abs(a.r - b.r)))
    return 2;
  if (eq(d, abs(a.r - b.r)))
    return 1;
  return 0;
}
/// 判断圆和点的位置关系
/// @return 0 表示包含，1 表示在圆上，2 表示在圆外
int check_cir_point_containment(Cir c, Pt p) {
  Vt d = dst(c.o, p);
  if (lt(d, c.r))
    return 0;
  if (eq(d, c.r))
    return 1;
  return 2;
}
// 求三角形内切圆
Cir incircle(Pt a, Pt b, Pt c) {
  Vt r = abs(det(a - b, a - c)) / (dst(a, b) + dst(a, c) + dst(b, c));
  Ln C(a, b), B(a, c);
  Vec shiftC = (c - proj(C, c)).resize(r);
  Vec shiftB = (b - proj(B, b)).resize(r);
  Pt o = inter(C + shiftC, B + shiftB);
  return Cir(o, r);
}
// 求三角形外接圆
Cir outcircle(Pt a, Pt b, Pt c) {
  Vec vc = r90_clockwise(a - b), vb = r90_clockwise(a - c);
  Pt mc = (a + b) / Vt(2), mb = (a + c) / Vt(2);
  Pt o = inter(Ln(mc, mc + vc), Ln(mb, mb + vb));
  Vt r = (o - a).length();
  return Cir(o, r);
}
// 圆点到直线的距离
Vt dst(Ln L, Cir c) { return dst(L, c.o); }
/// 求直线和圆的交点。如果相切那么返回两个相同的点。不会检查是否有交点。要求你提前判定
/// @return 一个 pair (p1, p2) 表示两个交点，满足 p1->p2 与 st->ed 方向相同
pair<Pt, Pt> cir_line_inter(Ln L, Cir c) {
  Vt d = dst(L, c);
  Vec shift = L.dir() * Vt(sqrt(max(Vt(0), c.r * c.r - d * d)));
  Pt mid = proj(L, c.o);
  return make_pair(mid - shift, mid + shift);
}
/// 求两圆的交点。如果相切那么返回两个相同的点。不会检查是否有交点。要求你提前判定
/// @return 一个 pair (p1, p2) 表示两个交点，保证 p1->p2 逆时针的圆弧被 c2 覆盖
pair<Pt, Pt> cir_inter(Cir c1, Cir c2) {
  assert(cir_inter_kind(c1, c2) > 0);
  assert(cir_inter_kind(c1, c2) < 4);
  Vec oo = c2.o - c1.o, ooo = r90_clockwise(oo);
  Vt d = oo.length();
  Vt cosT = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d);
  Pt p = oo.resize(c1.r * cosT) + c1.o;
  Vec shift = ooo.resize(c1.r * sqrt(1 - cosT * cosT));
  return make_pair(p + shift, p - shift);
}
/// 求圆外或圆上一点到圆的切线。不会检查是否在圆外。要求你提前判定
/// @return 一个 pair 表示两个切点，如果是圆上的点那么返回两个相同的点
pair<Pt, Pt> cir_point_tangent(Cir c, Pt p) {
  assert(check_cir_point_containment(c, p) != 0);
  Vec op = p - c.o, oop = r90_clockwise(op);
  Vt d = op.length();
  Vt x = c.r * c.r / d;
  Pt mid = c.o + op.resize(x);
  Vec shift = oop.resize(sqrt(c.r * c.r - x * x));
  return make_pair(mid + shift, mid - shift);
}
/// 将向量 v 旋转 a 角度
Vec rot(Vec v, Vt cos_a, Vt sin_a) {
  return Vec(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a);
}
/// @brief 求 c1, c2 的 c1 上切点位于 (c1.o -> c2.o) 向量 c1_side
/// 侧的外公切线，保证 Ln::st 是 c1 上的切点，且直线方向指向另一个切点
/// @param c1_side false 表示左侧，true 表示右侧
Ln cir_common_tangent_outer(Cir c1, Cir c2, bool c1_side) {
  Vt l = dst(c1.o, c2.o), d = c2.r - c1.r;
  assert(l >= d); // 否则没有公切线
  Vt sin_a = d / l, cos_a = sqrt(l * l - d * d) / l;
  Vec v = rot(c2.o - c1.o, cos_a, sin_a * (c1_side ? 1 : -1));
  Vec p = rot(v, 0, c1_side ? 1 : -1).resize(c1.r) + c1.o;
  return Ln(p, p + v);
}
/// @brief 求 c1, c2 的 c1 上切点位于 (c1.o -> c2.o) 向量 c1_side
/// 侧的内公切线，保证 Ln::st 是 c1 上的切点，且直线方向指向另一个切点
/// @param c1_side false 表示左侧，true 表示右侧
Ln cir_common_tangent_inner(Cir c1, Cir c2, bool c1_side) {
  Vt l = dst(c1.o, c2.o), d = c2.r + c1.r;
  assert(l >= d); // 否则没有公切线
  Vt sin_a = d / l, cos_a = sqrt(l * l - d * d) / l;
  Vec v = rot(c2.o - c1.o, cos_a, sin_a * (c1_side ? -1 : 1));
  Vec p = rot(v, 0, c1_side ? 1 : -1).resize(c1.r) + c1.o;
  return Ln(p, p + v);
}
/// 求弓形面积
/// @param r 半径
/// @param angle 弓形所对的圆心角，单位 rad
Vt cir_seg_area(Vt r, Vt angle) { return r * r * (angle - sin(angle)) / Vt(2); }
// 求两个圆交面积
Vt cir_inter_area(Cir c1, Cir c2) {
  Vt ans = 0;
  auto typ = cir_inter_kind(c1, c2);
  if (typ <= 1) {
    ans += PI * min(c1.r, c2.r) * min(c1.r, c2.r);
  } else if (cir_inter_kind(c1, c2) < 3) {
    auto pt = cir_inter(c1, c2);
    Vt t1 = abs(angle(pt.fi - c1.o, pt.se - c1.o)),
       t2 = abs(angle(pt.fi - c2.o, pt.se - c2.o));
    Pt p = inter(Ln(c1.o, c2.o), Ln(pt.fi, pt.se));
    if (on_ln_front(Seg(c1.o, c2.o), p))
      ans += cir_seg_area(c2.r, 2 * PI - t2);
    else
      ans += cir_seg_area(c2.r, t2);
    if (on_ln_front(Seg(c2.o, c1.o), p))
      ans += cir_seg_area(c1.r, 2 * PI - t1);
    else
      ans += cir_seg_area(c1.r, t1);
  }
  return ans;
}
/// 求圆与三角形 (c1, c1+v1, c1+v2) 的交的有向面积 (v1->v2)
/// @param v1 起始向量
/// @param v2 终止向量
Vt cir_tri_inter(Cir c, const Vec v1, const Vec v2) {
  if (parallel(v1, v2))
    return 0;
  const Ln l(c.o + v1, c.o + v2); // v1 -> v2
  // 扇形面积
  if (!lt(dst(l, c), c.r))
    return c.r * c.r * angle(v1, v2) / 2;
  auto pt = cir_line_inter(l, c);
  Seg s1(pt.fi, pt.se), s2(c.o + v1, c.o + v2);
  // 仍然是扇形面积
  if (!is_seg_inter(s1, s2))
    return c.r * c.r * angle(v1, v2) / 2;
  Vec u1 = v1, u2 = v2;
  Vt res = 0;
  if (v1.length() > c.r) { // d1 -> pt.fi 是个扇形
    res += c.r * c.r * angle(v1, u1 = pt.fi - c.o) / 2;
  }
  if (v2.length() > c.r) { // pt.se -> d2 是个扇形
    res += c.r * c.r * angle(u2 = pt.se - c.o, v2) / 2;
  }
  res += det(u1, u2) / 2;
  return res;
}
/// 圆反演
struct CirInv {
  Cir c0;
  CirInv(Cir c) : c0(c) {}
  Pt p2p(Pt p) {
    Vec v = p - c0.o;
    return v.resize(c0.r * c0.r / v.length()) + c0.o;
  }
  // 不 check 退化的情况
  Cir c2c(Cir c) {
    Vec v = c.o - c0.o;
    Vt d = v.length();
    Vt r1 = fabs(1 / (d - c.r) - 1 / (d + c.r)) * c0.r * c0.r / 2;
    Pt o =
        v.resize(fabs(1 / (d - c.r) + 1 / (d + c.r)) * c0.r * c0.r / 2) + c0.o;
    return Cir(o, r1);
  }
};

// p 是否在 ln 左半平面内
bool in_left(Ln ln, Pt p) { return gt(det(ln.vec(), p - ln.st), 0); }
bool in_left_include(Ln ln, Pt p) { return in_left(ln, p) || on_ln(ln, p); }

// 求半平面交（直线左边的半平面）
// 交集为空则返回空集
// 若为开放区域返回对应的直线（这种情况还未对拍充分验证）
// 若区域封闭，保证求出来的半平面交中直线的两个点是凸多边形上的线段端点
vector<Ln> half_planar_inter(const vector<Ln> &lns) {
  vector<pair<Vt, int>> vs(lns.size()); // sort by angle
  for_each(i, lns) vs[i] = make_pair(lns[i].vec().ang(), i);
  sort(vs.begin(), vs.end());
  for_each(i, vs) {
    if (!lt(vs[i].fi - vs[i - 1].fi, PI)) {
      FOR(j, 0, i - 1) vs[j].fi += 2 * PI;
      rotate(vs.begin(), vs.begin() + i, vs.end());
    }
  }
  vector<Vt> qA(lns.size());                 // angles
  vector<Ln> qL(lns.size(), Ln(Pt(), Pt())); // lines
  vector<Pt> qP(lns.size());                 // cross points
  int ql = 0, qr = -1;
  for_each(i, vs) {
    Vt ang = vs[i].fi;
    const Ln ln = lns[vs[i].se];
    assert(ln.vec());
    // 如果交点在 ln 右边，那么这个交点对应的线是无用的
    while (ql < qr && !in_left(ln, qP[qr]))
      --qr;
    while (ql < qr && !in_left(ln, qP[ql + 1]))
      ++ql;
    if (ql <= qr && eq(ang, qA[qr])) {
      if (!in_left(ln, qL[qr].st))
        --qr;
      else
        continue;
    }
    // 已经封闭，这条没用
    if (ql < qr && gt(qA[qr] - PI, qA[ql]) &&
        in_left_include(ln, inter(qL[ql], qL[qr])))
      continue;
    ++qr, qA[qr] = ang, qL[qr] = ln;
    if (ql < qr) {
      // 交为空
      if (!lt(qA[qr] - qA[qr - 1], PI))
        return vector<Ln>();
      qP[qr] = inter(qL[qr - 1], qL[qr]);
    }
  }
  vector<Ln> res(qL.begin() + ql, qL.begin() + qr + 1);
  // 开放空间
  if (!lt(qA[ql] + PI, qA[qr]))
    return res;
  qP[ql] = inter(qL[ql], qL[qr]);
  for_each(i, res) res[i].ed = res[(i + 1) % res.size()].st = qP[ql + i];
  // for_each(i, res) assert(res[i].vec());
  return res;
}
} // namespace cg

using namespace std;

struct Arc {
  cg::Vec v1, v2;
  cg::Vt ang1, ang2;
};

bool arc_cmp(const Arc a, const Arc b) { return a.ang1 < b.ang1; }

struct CirArc {
  cg::Cir c;
  cg::Vec v1, v2;
  cg::Pt p1() const { return c.o + v1; }
  cg::Pt p2() const { return c.o + v2; }
};

/// c1 被 c2 覆盖的圆弧，逆时针方向
Arc arc_cover(cg::Cir c1, cg::Cir c2) {
  auto pt = cg::cir_inter(c1, c2);
  auto v1 = pt.fi - c1.o, v2 = pt.se - c1.o, ve = cg::Vec(1, 0);
  auto ang1 = cg::angle(ve, v1), ang2 = cg::angle(ve, v2);
  return Arc{v1, v2, ang1, ang2};
}

vector<CirArc> exposed_arcs(const cg::Cir c, vector<Arc> arcs) {
  for (const auto a : arcs)
    assert(a.ang1 <= a.ang2);
  sort(arcs.begin(), arcs.end(), arc_cmp);

  cg::Vt ang_last = -cg::PI;
  cg::Vec v_last(-c.r, 0);

  vector<CirArc> r;
  for (const auto a : arcs) {
    if (cg::lt(ang_last, a.ang1)) {
      r.push_back({c, v_last, a.v1});
    }

    if (ang_last < a.ang2) {
      ang_last = a.ang2;
      v_last = a.v2;
    }
  }
  if (cg::lt(ang_last, cg::PI)) {
    if (r.empty() || cg::Vec(-c.r, 0) - r[0].v1) {
      r.push_back({c, v_last, cg::Vec(-c.r, 0)});
    } else {
      r[0].v1 = v_last;
    }
  }
  return r;
}

int n, q;
vector<cg::Cir> cs;
void work(const vector<CirArc> &exposed) {
  int a, b, c, d;
  cin >> a >> b >> c >> d;
  cg::Pt p1(a, b), p2(a + c, b), p3(a + c, b + d), p4(a, b + d);
  cg::Ln l1(p1, p2), l2(p2, p3), l3(p3, p4), l4(p4, p1);

  cg::Vt ans = 0;
  for (const auto &a : exposed) {
    const cg::Pt a_p1 = a.p1(), a_p2 = a.p2();

    // 矩形弓形面积交
    vector<cg::Ln> arcseg_lns = {l1, l2, l3, l4}, arcseg_polygon;
    if (a_p1 - a_p2) {
      arcseg_lns.push_back(cg::Ln(a_p2, a_p1));
      arcseg_polygon = cg::half_planar_inter(arcseg_lns);
    } else {
      arcseg_polygon = arcseg_lns;
    }
    for (auto seg : arcseg_polygon) {
      auto v1 = seg.st - a.c.o, v2 = seg.ed - a.c.o;
      auto area = cg::cir_tri_inter(a.c, v1, v2);
      ans += area;
    }

    cg::Pt pts[] = {{0, 0}, a_p1, a_p2};
    if (det(a_p1, a_p2) < 0)
      swap(pts[1], pts[2]);

    // 矩形三角形面积交
    if (a_p1 - a_p2 && a_p1 && a_p2) {
      vector<cg::Ln> trireg_lns = {l1,
                                   l2,
                                   l3,
                                   l4,
                                   cg::Ln(pts[0], pts[1]),
                                   cg::Ln(pts[1], pts[2]),
                                   cg::Ln(pts[2], pts[0])};
      auto trireg_polygon = cg::half_planar_inter(trireg_lns);
      const cg::Vt sign = det(a_p1, a_p2) < 0 ? -1 : 1;
      for (const auto seg : trireg_polygon) {
        ans += det(seg.st, seg.ed) / 2 * sign;
      }
    }
  }

  ans = ans * 100 / c / d;
  cout << setprecision(10) << fixed << ans << endl;
  // todo
}

int main() {
  cin.tie(0);
  cout.tie(0);
  ios::sync_with_stdio(false);

  cin >> n >> q;
  cs.reserve(n);
  set<pair<pair<int, int>, int>> cset;
  FOR(i, 1, n) {
    int x, y, r;
    cin >> x >> y >> r;
    if (cset.insert({{x, y}, r}).second) {
      cs.push_back(cg::Cir(cg::Pt(x, y), r));
    }
  }

  vector<CirArc> exposed;
  FOR(i, 0, n - 1) {
    auto &c = cs[i];
    bool covered = false;

    vector<Arc> arcs;
    FOR(j, 0, n - 1) if (j != i) {
      auto &c2 = cs[j];
      int typ = cg::cir_inter_kind(c, c2);

      if (typ <= 1) {
        if (!cg::gt(c.r, c2.r)) { // 被包含
          covered = true;
          break;
        } else { // 包含该圆
          continue;
        }
      }
      if (typ > 2)
        continue;

      auto a = arc_cover(c, c2);
      cg::Vec v_pi(-c.r, 0);
      if (a.ang1 < a.ang2) {
        arcs.push_back(a);
      } else {
        arcs.push_back(Arc{a.v1, v_pi, a.ang1, cg::PI});
        arcs.push_back(Arc{v_pi, a.v2, -cg::PI, a.ang2});
      }
    }

    if (covered)
      continue;

    auto r = exposed_arcs(c, arcs);
    exposed.insert(exposed.end(), r.begin(), r.end());
  }

  cerr << "exposed: " << exposed.size() << endl;

  FOR(i, 1, q) work(exposed);

  return 0;
}
```

