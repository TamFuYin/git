# T1

场切签到了终于

---

$k=2$，每个质因子最多由一个人使用，答案就是 $\pi(m)$。

$k=3$，每个质因子最多由两个人使用。直接构造 $p,p^2$ 就是最优的。这是因为对于 $p^2>m$ 的质数而言，只能通过 $pq$ 的方式贡献，但这样 $p$ 和 $q$ 之间必有一个数 $\le \sqrt m$，而这个较小的数必然不愿意出让。

$k=4$，则每个质因子最多由三个人使用。

1. $p\le \sqrt[3]m$，+3
2. $\sqrt[3]m<p\le \sqrt m$，+2
3. $\sqrt m<p\le m$，+1

2 类和 3 类可以两两匹配，其中一个 3 类可以匹配两次，多余的 2 类之间也可以两两匹配。

$k=5$，则每个质因子最多由四个人使用。

1. $p\le \sqrt[4] m$，+4
2. $\sqrt[4]m<p\le \sqrt[3]m$，+3，此类 $p$ 只能匹配一次
3. $\sqrt[3]m<p\le\sqrt m$，+2，此类 $p$ 能匹配两次
4. $\sqrt m<p\le m$，+1，此类 $p$ 能匹配三次

首先肯定是先做两个点匹配的，先做 2 类跟 4 类的匹配。

如果 2 类点有剩，那么剩下的 4 类点也不可能跟 3 类点匹配了。那么剩下来就是 2 类点和 3 类点的两两匹配以及 2 类点之间的两两匹配，跟 $k=4$ 一样。

否则，剩下的 4 类跟 3 类匹配以及 3 类两两匹配，但是应当注意到不能出现两个一样的数。其实跟上面的匹配是大体一样的。匹配完剩下的 4 可以直接扔掉了，如果还剩一些 3，可以两两匹配。但是如果还剩一些 3 可以匹配两次怎么办呢？如果数量 $>2$ 可以缀成一个环形的匹配，否则只好尽量跟前面的 3 相匹配。

可以注意到不存在三个点进行匹配的。

# T2

D2T2 太多啦.jpg

题述条件等价于任意点所在回路的异或线性基都是满秩的，或者说，连通块内所有回路合起来的线性基是满秩的。

一个经典结论是，你只需要看所有只包含一条非树边的环。

$w=0$ 怎么搞？相当于只有图联通的性质。貌似差不多就是 [城市规划](https://www.luogu.com.cn/problem/P4841)，属于经典题了。

具体而言，一个连通块内的边是可以随便选的，这个是独立的，可以预先乘进去。然后每个连通块影响答案的部分只有点数。令全集 $U$ 表示所有点数构成的（可重）集合。

设 $f(S)$ 为点数集合为 $S$ 形成的无向连通图的数量，$g(S)$ 为允许不连通的数量。则 $g(S)=2^{\sum_{i=1}^{|S|}S_i\sum_{j=i+1}^{|S|}S_j}=2^{(sum^2(S)-sum(S))/2}$。

枚举 $S_1$ 所在连通块，我们有
$$
g(S)=\sum_{T\subseteq S,S_1\in T}f(T)g(S\backslash T)
$$
给原图建生成树，预先形成的环先插进线性基，那么，只考虑同一个原图连通块时，其所有未选的边都是非树边，且是可以随意控制的。

容易看出，对答案有影响的只有已有环的线性基的秩和未连边的数量。记在 $w$ 维空间中，原来有 $n$ 维的线性空间，你还可以往里面放 $k$ 个向量。考虑容斥，使得结果限制在一个 $m$ 维空间里是容易的，就是 $2^{mk}$。

剩下就是把不同连通块的答案合起来，跟 $w=0$ 差不多。

# T3

赛时的思路貌似完全假掉了？

以下是赛时的思路：

一堆石子：$\lceil\lg a_i\rceil$。

两堆石子：$a_1$ 和 $a_2$ 中必然存在一个是 $\ge \frac{a_1+a_2}2$ 的，因此仍然是 $\lceil\lg (a_1+a_2)\rceil$。

更多堆石子：显然，我们只聚焦于最多的一堆即可，如果最多的一堆 $<\lceil\frac{\sum a_i}2\rceil$，那就全部把它问完。显然，最坏情况下，相当于把这一堆整堆拿走。

然后被 ±1 WA 送走了

---

首先其实**完全不必二分**。为什么？题目给出的输入方式已经在提示你了。因为你二分也是 $\lceil \lg a\rceil$，你不如每次取 $2^{\lfloor \lg a\rfloor}$，不难发现这样最坏情况下也是 $\lceil \lg a\rceil$。

所以，一个策略就是每次找到最大值 $a$，然后在这一堆中拿走 $2^{\lfloor\lg a\rfloor}$，称策略 2。

然而，这种策略并非最优。有时我们选择检验整堆，这样要么相当于跳过这一堆，要么完全进入这一堆，称策略 1。

如何判断？考虑二分答案。

策略 1 于短期无利而于长期有利，因此，只要当前二分值允许我们能够完全进入这一堆，我们就选择策略 1，否则，我们拿走 $2^{\lfloor\lg a\rfloor}$。

```pseudocode
if(...){
    ans=max(ans,times+ceil(log2(x)))
}
else{
    ans=max(ans,times+floor(log2(x)))
    Q.push(x-2^floor(log2(x)))
}
++times
```

因此可以直接一直使用策略 1，得到一个大致的答案（即每个数从大到小的排名+ceil(log(a_i))）再 check。这样可以少掉一个二分的牢哥。

关键还是在优化 check。

注意到对于每个 $\lfloor \lg x\rfloor$ 最多做一次策略 2，这是因为如果后面还有 $\ge \lfloor \lg x\rfloor$ 的数，我们还不如直接就策略 1 了，反正这个二分值足够大。

同时我们发现，对于一个 $\lfloor \lg x\rfloor $，只有 $x$ 的最小值会出现策略 2。

因此只要能够快速求出最小值即可。同时注意到 $x-2^{\lfloor \lg x\rfloor }$ 也会参与最小值的比较，因此实际上要求的是比较一个后缀的最小值。这个可以用 SA + ST 表来得到。